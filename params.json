{"name":"Lua0","tagline":"lua simple study","body":"`这篇文章我不知道该不该写：`   \r\n　　由于我也是接触lua不久［还是之前项目需要，于是就边写代码边学习］，其实我每次学习一门新的语言的时候\r\n　　（我不会刻意的去学习），我觉得语言本身并不是问题而是想法［算法］，比如你要去进行切割字符串，你知道\r\n　　在go语言中有split这个函数，那么类似lua中是不是也应该有恩，这个时候只需要打开lua的文档进行search就ok[\r\n　　当然这个地方又是考验一个人search的功底了就好像gg输入的关键字一样]好了闲话就不多说了：      \r\n\r\nlua学习的过程：     \r\n　首先lua是一个动态类型的语言，是解释执行的．   \r\n　　值得注意的是lua的语法是很简单的：   \r\n   \r\n1.基础数据类型       \r\n====\r\n* number   \r\nnumber类型用于表示实数，c/c++里面的double类型一样。可以使用数学函数math.floor（向下取整）和math.ceil（向上取整）\r\n进行取整操作。  \r\n\r\n```lua\r\nlocal order = 3.0\r\nlocal score = 98.5\r\nprint(math.floor(order))   -->output:3   \r\nprint(math.ceil(score))    -->output:99 \r\n```\r\n\r\n* nil（空）\r\n\r\nnil是一种类型Lua将nil用于表示“无效值”。一个变量在第一次赋值前的默认值是nil，将nil赋予给一个全局变量就等同于删除它。\r\n\r\nlocal num\r\nprint(num)        -->output:nil\r\n\r\nnum = 100\r\nprint(num)        -->output:100\r\n\r\nboolean（布尔）\r\n\r\n布尔类型，可选值true/false；Lua中nil和false为“假”，其它所有值均为“真”。\r\n\r\n* string（字符串）\r\n注意该类型：和c++中的字符串是不一样的，不可以进行修改字符串中的某个值，也不可以访问相应下标的字符．\r\n在lua中使用了一中引用的方式来存储字符串．\r\n\r\n\r\n* table(表)\r\n\r\ntable类型实现了“关联数组”。“关联数组” 是一种具有特殊索引方式的数组，索引可为字符串string或(整)数number类型。\r\n注意：其下表是从１开始的［若没有使用其他的作为ｋｅｙ］．其中表也是lua中唯一一个数据结构，很强大的．\r\n\r\n* function(函数)\r\n\r\n在Lua中函数 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值。\r\n如下：\r\nfunction foo() ... end\r\n\r\n等价于  \r\n\r\nfoo = function () ... end\r\n\r\n\r\n\r\n2.值得注意的是lua中的逻辑运算发和其他语言中是不一样的：\r\n====\r\n　在其他语言中其逻辑运算最终都是返回一个bool类型的值，而在lua中则不是的，还有就是在lua中只有false和nil是假，\r\n其他的都是真．      \r\n　 在lua中其逻辑运算符如下：      \r\n　a = a or b  这个的含义等价于：　a = a ? a:b; 相当于给a 一个默认值，如果a是有值的话则赋值ａ．    \r\n　 在lua中没有三目运算符，但是可以这样写：　val =  a and b or c      \r\n  注意：其实上面这么写的三目运算符还有点瑕疵：假如b此时的值是nil则得不到b而是ｃ     \r\n　改善后：(a and {b} or {c})[1] 这样即使b是nil也可以取到了，主要利用刚才说的原则－－条件假的只有false 和　nil      \r\n\r\n  说白了在lua中的逻辑运算最终返回的是一个值，不一定只是bool而要看其参加运算的变量．    \r\n\r\n\r\n3.利用lua中的table可以做很多事情\r\n====\r\n　　1.利用table可以做一个hash\r\n  2.可以做一个驱动表\r\n　　3.还可以行面向对象的编程[把数据放到表中以及函数]．\r\n　　4.设置元表等［相当于一种重载］\r\n\r\n4.lua可以与c c++等语言之间的交互：\r\n====\r\n　　主要就是在lua和c之间有一个栈进行保存传递的参数，然后根据相应的约定进行运算．后面文章会详细讲解．\r\n \r\n\r\n5.ffi机制\r\n====\r\n　The FFI library allows calling external C functions and using C data structures from pure Lua code. 官方的介绍：\r\nFFI库，是LuaJIT中最重要的一个扩展库。它允许从纯Lua代码调用外部C函数，使用C数据结构。有了它，就不用再像Lua标准math库一样，编写Lua扩展库。把开发者从开发Lua扩展C库（语言/功能绑定库）的繁重工作中释放出来。　\r\n当然这个要使用luajit才可以的．\r\n如下：\r\nlocal ffi = require(\"ffi\")\r\nffi.cdef[[\r\nint printf(const char *fmt, ...);\r\n]]\r\nffi.C.printf(\"Hello %s!\", \"world\")\r\n\r\n\r\n6.lua中的.与：的区别\r\n====\r\n```lua\r\nlocal str = \"abcde\"\r\nprint(\"case 1:\", str:sub(1, 2))\r\nprint(\"case 2:\", str.sub(str, 1, 2))\r\n```\r\n\r\n输出结果一样：\r\ncase 1: ab\r\ncase 2: ab\r\n使用:就可以不用在传递自己了（self）.\r\n\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"lua simple study table ffi metatable ","note":"Don't delete this file! It's used internally to help with page regeneration."}